import{r as y}from"./index-3d883fcf.js";var ye=e=>e instanceof HTMLElement;const ie={BLUR:"blur",CHANGE:"change",INPUT:"input"},Y={onBlur:"onBlur",onChange:"onChange",onSubmit:"onSubmit",onTouched:"onTouched",all:"all"},or="select",je="undefined",K={max:"max",min:"min",maxLength:"maxLength",minLength:"minLength",pattern:"pattern",required:"required",validate:"validate"};function Fr({ref:e},t,n){ye(e)&&n&&(e.addEventListener(t?ie.CHANGE:ie.INPUT,n),e.addEventListener(ie.BLUR,n))}var _=e=>e==null;const ar=e=>typeof e=="object";var P=e=>!_(e)&&!Array.isArray(e)&&ar(e)&&!(e instanceof Date),me=e=>/^\w*$/.test(e),ce=e=>e.filter(Boolean),fr=e=>ce(e.replace(/["|']/g,"").replace(/\[/g,".").replace(/\]/g,"").split("."));function D(e,t,n){let c=-1;const l=me(t)?[t]:fr(t),u=l.length,o=u-1;for(;++c<u;){const v=l[c];let a=n;if(c!==o){const V=e[v];a=P(V)||Array.isArray(V)?V:isNaN(+l[c+1])?{}:[]}e[v]=a,e=e[v]}return e}var Pe=(e,t={})=>{for(const n in e)me(n)?t[n]=e[n]:D(t,n,e[n]);return t},L=e=>e===void 0,O=(e={},t,n)=>{const c=ce(t.split(/[,[\].]+?/)).reduce((l,u)=>_(l)?l:l[u],e);return L(c)||c===e?L(e[t])?n:e[t]:c},wr=(e,t)=>{for(const n in e)if(O(t,n)){const c=e[n];if(c){if(c.ref.focus&&L(c.ref.focus()))break;if(c.options){c.options[0].ref.focus();break}}}},Ze=(e,t)=>{ye(e)&&e.removeEventListener&&(e.removeEventListener(ie.INPUT,t),e.removeEventListener(ie.CHANGE,t),e.removeEventListener(ie.BLUR,t))};const er={isValid:!1,value:null};var lr=e=>Array.isArray(e)?e.reduce((t,n)=>n&&n.ref.checked?{isValid:!0,value:n.ref.value}:t,er):er,jr=e=>[...e].filter(({selected:t})=>t).map(({value:t})=>t),Ee=e=>e.type==="radio",dr=e=>e.type==="file",ue=e=>e.type==="checkbox",yr=e=>e.type===`${or}-multiple`;const rr={value:!1,isValid:!1},tr={value:!0,isValid:!0};var gr=e=>{if(Array.isArray(e)){if(e.length>1){const l=e.filter(u=>u&&u.ref.checked).map(({ref:{value:u}})=>u);return{value:l,isValid:!!l.length}}const{checked:t,value:n,attributes:c}=e[0].ref;return t?c&&!L(c.value)?L(n)||n===""?tr:{value:n,isValid:!0}:tr:rr}return rr};function se(e,t,n,c,l){const u=e.current[t];if(u){const{ref:{value:o,disabled:v},ref:a,valueAsNumber:V,valueAsDate:G,setValueAs:w}=u;return v&&c?void 0:dr(a)?a.files:Ee(a)?lr(u.options).value:yr(a)?jr(a.options):ue(a)?gr(u.options).value:l?o:V?o===""?NaN:+o:G?a.valueAsDate:w?w(o):o}if(n)return O(n.current,t)}function ke(e){return e?!(e instanceof HTMLElement)||e.nodeType===Node.DOCUMENT_NODE?!1:ke(e.parentNode):!0}var k=e=>P(e)&&!Object.keys(e).length,He=e=>typeof e=="boolean";function xr(e,t){const n=t.slice(0,-1).length;let c=0;for(;c<n;)e=L(e)?c++:e[t[c++]];return e}function T(e,t){const n=me(t)?[t]:fr(t),c=n.length==1?e:xr(e,n),l=n[n.length-1];let u;c&&delete c[l];for(let o=0;o<n.slice(0,-1).length;o++){let v=-1,a;const V=n.slice(0,-(o+1)),G=V.length-1;for(o>0&&(u=e);++v<V.length;){const w=V[v];a=a?a[w]:e[w],G===v&&(P(a)&&k(a)||Array.isArray(a)&&!a.filter(M=>P(M)&&!k(M)||He(M)).length)&&(u?delete u[w]:delete e[w]),u=a}}return e}const nr=(e,t)=>e&&e.ref===t;function Lr(e,t,n,c,l,u){const{ref:o,ref:{name:v}}=n,a=e.current[v];if(!l){const V=se(e,v,c);!L(V)&&D(c.current,v,V)}if(!o.type||!a){delete e.current[v];return}Ee(o)||ue(o)?Array.isArray(a.options)&&a.options.length?(ce(a.options).forEach((V={},G)=>{(ke(V.ref)&&nr(V,V.ref)||u)&&(Ze(V.ref,t),T(a.options,`[${G}]`))}),a.options&&!ce(a.options).length&&delete e.current[v]):delete e.current[v]:(ke(o)&&nr(a,o)||u)&&(Ze(o,t),delete e.current[v])}var ee=e=>_(e)||!ar(e);function $e(e,t){if(ee(e)||ee(t))return t;for(const n in t){const c=e[n],l=t[n];try{e[n]=P(c)&&P(l)||Array.isArray(c)&&Array.isArray(l)?$e(c,l):l}catch{}}return e}function Z(e,t,n){if(ee(e)||ee(t)||e instanceof Date||t instanceof Date)return e===t;if(!y.isValidElement(e)){const c=Object.keys(e),l=Object.keys(t);if(c.length!==l.length)return!1;for(const u of c){const o=e[u];if(!(n&&u==="ref")){const v=t[u];if((P(o)||Array.isArray(o))&&(P(v)||Array.isArray(v))?!Z(o,v,n):o!==v)return!1}}}return!0}function Be(e,t,n,c,l){let u=-1;for(;++u<e.length;){for(const o in e[u])Array.isArray(e[u][o])?(!n[u]&&(n[u]={}),n[u][o]=[],Be(e[u][o],O(t[u]||{},o,[]),n[u][o],n[u],o)):Z(O(t[u]||{},o),e[u][o])?D(n[u]||{},o):n[u]=Object.assign(Object.assign({},n[u]),{[o]:!0});c&&!n.length&&delete c[l]}return n}var Nr=(e,t,n)=>$e(Be(e,t,n.slice(0,e.length)),Be(t,e,n.slice(0,e.length))),z=e=>typeof e=="string",Te=(e,t,n,c,l)=>{const u={};for(const o in e.current)(L(l)||(z(l)?o.startsWith(l):Array.isArray(l)&&l.find(v=>o.startsWith(v))))&&(u[o]=se(e,o,void 0,c));return n?Pe(u):$e(t,Pe(u))},Ir=({errors:e,name:t,error:n,validFields:c,fieldsWithValidation:l})=>{const u=L(n),o=O(e,t);return u&&!!o||!u&&!Z(o,n,!0)||u&&O(l,t)&&!O(c,t)},br=e=>e instanceof RegExp,le=e=>P(e)&&!br(e)?e:{value:e,message:""},hr=e=>typeof e=="function",We=e=>z(e)||y.isValidElement(e);function sr(e,t,n="validate"){if(We(e)||He(e)&&!e)return{type:n,message:We(e)?e:"",ref:t}}var Mr=(e,t,n,c,l)=>t?Object.assign(Object.assign({},n[e]),{types:Object.assign(Object.assign({},n[e]&&n[e].types?n[e].types:{}),{[c]:l||!0})}):{},Fe=async(e,t,{ref:n,ref:{value:c},options:l,required:u,maxLength:o,minLength:v,min:a,max:V,pattern:G,validate:w},M)=>{const B=n.name,E={},N=Ee(n),C=ue(n),ge=N||C,J=c==="",W=Mr.bind(null,B,t,E),R=(m,A,p,S=K.maxLength,I=K.minLength)=>{const Q=m?A:p;E[B]=Object.assign({type:m?S:I,message:Q,ref:n},W(m?S:I,Q))};if(u&&(!N&&!C&&(J||_(c))||He(c)&&!c||C&&!gr(l).isValid||N&&!lr(l).isValid)){const{value:m,message:A}=We(u)?{value:!!u,message:u}:le(u);if(m&&(E[B]=Object.assign({type:K.required,message:A,ref:ge?((e.current[B].options||[])[0]||{}).ref:n},W(K.required,A)),!t))return E}if((!_(a)||!_(V))&&c!==""){let m,A;const p=le(V),S=le(a);if(isNaN(c)){const I=n.valueAsDate||new Date(c);z(p.value)&&(m=I>new Date(p.value)),z(S.value)&&(A=I<new Date(S.value))}else{const I=n.valueAsNumber||parseFloat(c);_(p.value)||(m=I>p.value),_(S.value)||(A=I<S.value)}if((m||A)&&(R(!!m,p.message,S.message,K.max,K.min),!t))return E}if(z(c)&&!J&&(o||v)){const m=le(o),A=le(v),p=!_(m.value)&&c.length>m.value,S=!_(A.value)&&c.length<A.value;if((p||S)&&(R(p,m.message,A.message),!t))return E}if(z(c)&&G&&!J){const{value:m,message:A}=le(G);if(br(m)&&!m.test(c)&&(E[B]=Object.assign({type:K.pattern,message:A,ref:n},W(K.pattern,A)),!t))return E}if(w){const m=se(e,B,M,!1,!0),A=ge&&l?l[0].ref:n;if(hr(w)){const p=await w(m),S=sr(p,A);if(S&&(E[B]=Object.assign(Object.assign({},S),W(K.validate,S.message)),!t))return E}else if(P(w)){let p={};for(const[S,I]of Object.entries(w)){if(!k(p)&&!t)break;const Q=await I(m),be=sr(Q,A,S);be&&(p=Object.assign(Object.assign({},be),W(S,be.message)),t&&(E[B]=p))}if(!k(p)&&(E[B]=Object.assign({ref:A},p),!t))return E}}return E};const _e=(e,t,n=[])=>{for(const c in t){const l=e+(P(t)?`.${c}`:`[${c}]`);ee(t[c])?n.push(l):_e(l,t[c],n)}return n};var ir=(e,t,n,c,l)=>{let u;return n.add(t),k(e)||(u=O(e,t),(P(u)||Array.isArray(u))&&_e(t,u).forEach(o=>n.add(o))),L(u)?l?c:O(c,t):u},Tr=({isOnBlur:e,isOnChange:t,isOnTouch:n,isTouched:c,isReValidateOnBlur:l,isReValidateOnChange:u,isBlurEvent:o,isSubmitted:v,isOnAll:a})=>a?!1:!v&&n?!(c||o):(v?l:e)?!o:(v?u:t)?o:!0,we=e=>e.substring(0,e.indexOf("["));const Pr=(e,t)=>RegExp(`^${t}([|.)\\d+`.replace(/\[/g,"\\[").replace(/\]/g,"\\]")).test(e);var Br=(e,t)=>[...e].some(n=>Pr(t,n)),Wr=e=>e.type===`${or}-one`;function Hr(e,t){const n=new MutationObserver(()=>{for(const c of Object.values(e.current))if(c&&c.options)for(const l of c.options)l&&l.ref&&ke(l.ref)&&t(c);else c&&ke(c.ref)&&t(c)});return n.observe(window.document,{childList:!0,subtree:!0}),n}var de=typeof window!==je&&typeof document!==je;function X(e){let t;if(ee(e)||de&&(e instanceof File||ye(e)))return e;if(e instanceof Date)return t=new Date(e.getTime()),t;if(e instanceof Set){t=new Set;for(const n of e)t.add(n);return t}if(e instanceof Map){t=new Map;for(const n of e.keys())t.set(n,X(e.get(n)));return t}t=Array.isArray(e)?[]:{};for(const n in e)t[n]=X(e[n]);return t}var cr=e=>({isOnSubmit:!e||e===Y.onSubmit,isOnBlur:e===Y.onBlur,isOnChange:e===Y.onChange,isOnAll:e===Y.all,isOnTouch:e===Y.onTouched}),ur=e=>Ee(e)||ue(e);const $r=typeof window===je,ne=de?"Proxy"in window:typeof Proxy!==je;function qr({mode:e=Y.onSubmit,reValidateMode:t=Y.onChange,resolver:n,context:c,defaultValues:l={},shouldFocusError:u=!0,shouldUnregister:o=!0,criteriaMode:v}={}){const a=y.useRef({}),V=y.useRef({}),G=y.useRef({}),w=y.useRef(new Set),M=y.useRef({}),B=y.useRef({}),E=y.useRef({}),N=y.useRef({}),C=y.useRef(l),ge=y.useRef(!1),J=y.useRef(!1),W=y.useRef(),R=y.useRef({}),m=y.useRef({}),A=y.useRef(c),p=y.useRef(n),S=y.useRef(new Set),I=y.useRef(cr(e)),{isOnSubmit:Q,isOnTouch:be}=I.current,H=v===Y.all,[oe,vr]=y.useState({isDirty:!1,isValidating:!1,dirtyFields:{},isSubmitted:!1,submitCount:0,touched:{},isSubmitting:!1,isSubmitSuccessful:!1,isValid:!Q,errors:{}}),x=y.useRef({isDirty:!ne,dirtyFields:!ne,touched:!ne||be,isValidating:!ne,isSubmitting:!ne,isValid:!ne}),f=y.useRef(oe),he=y.useRef(),{isOnBlur:Ge,isOnChange:qe}=y.useRef(cr(t)).current;A.current=c,p.current=n,f.current=oe,R.current=o?{}:k(R.current)?X(l):R.current;const F=y.useCallback((r={})=>{ge.current||(f.current=Object.assign(Object.assign({},f.current),r),vr(f.current))},[]),ze=()=>x.current.isValidating&&F({isValidating:!0}),ve=y.useCallback((r,i,s=!1,b={},g)=>{let d=s||Ir({errors:f.current.errors,error:i,name:r,validFields:N.current,fieldsWithValidation:E.current});const h=O(f.current.errors,r);i?(T(N.current,r),d=d||!h||!Z(h,i,!0),D(f.current.errors,r,i)):((O(E.current,r)||p.current)&&(D(N.current,r,!0),d=d||h),T(f.current.errors,r)),(d&&!_(s)||!k(b)||x.current.isValidating)&&F(Object.assign(Object.assign(Object.assign({},b),p.current?{isValid:!!g}:{}),{isValidating:!1}))},[]),pe=y.useCallback((r,i)=>{const{ref:s,options:b}=a.current[r],g=de&&ye(s)&&_(i)?"":i;Ee(s)?(b||[]).forEach(({ref:d})=>d.checked=d.value===g):dr(s)&&!z(g)?s.files=g:yr(s)?[...s.options].forEach(d=>d.selected=g.includes(d.value)):ue(s)&&b?b.length>1?b.forEach(({ref:d})=>d.checked=Array.isArray(g)?!!g.find(h=>h===d.value):g===d.value):b[0].ref.checked=!!g:s.value=g},[]),xe=y.useCallback((r,i)=>{if(x.current.isDirty){const s=ae();return r&&i&&D(s,r,i),!Z(s,C.current)}return!1},[]),Oe=y.useCallback((r,i=!0)=>{if(x.current.isDirty||x.current.dirtyFields){const s=!Z(O(C.current,r),se(a,r,R)),b=O(f.current.dirtyFields,r),g=f.current.isDirty;s?D(f.current.dirtyFields,r,!0):T(f.current.dirtyFields,r);const d={isDirty:xe(),dirtyFields:f.current.dirtyFields},h=x.current.isDirty&&g!==d.isDirty||x.current.dirtyFields&&b!==O(f.current.dirtyFields,r);return h&&i&&F(d),h?d:{}}return{}},[]),Le=y.useCallback(async(r,i)=>{const s=(await Fe(a,H,a.current[r],R))[r];return ve(r,s,i),L(s)},[ve,H]),Ke=y.useCallback(async r=>{const{errors:i}=await p.current(ae(),A.current,H),s=f.current.isValid;if(Array.isArray(r)){const b=r.map(g=>{const d=O(i,g);return d?D(f.current.errors,g,d):T(f.current.errors,g),!d}).every(Boolean);return F({isValid:k(i),isValidating:!1}),b}else{const b=O(i,r);return ve(r,b,s!==k(i),{},k(i)),!b}},[ve,H]),Ve=y.useCallback(async r=>{const i=r||Object.keys(a.current);if(ze(),p.current)return Ke(i);if(Array.isArray(i)){!r&&(f.current.errors={});const s=await Promise.all(i.map(async b=>await Le(b,null)));return F({isValidating:!1}),s.every(Boolean)}return await Le(i)},[Ke,Le]),Je=y.useCallback((r,i,{shouldDirty:s,shouldValidate:b})=>{const g={};D(g,r,i);for(const d of _e(r,i))a.current[d]&&(pe(d,O(g,d)),s&&Oe(d),b&&Ve(d))},[Ve,pe,Oe]),Qe=y.useCallback((r,i,s)=>{if(!o&&!ee(i)&&D(R.current,r,Object.assign({},i)),a.current[r])pe(r,i),s.shouldDirty&&Oe(r),s.shouldValidate&&Ve(r);else if(!ee(i)&&(Je(r,i,s),S.current.has(r))){const b=we(r)||r;D(V.current,r,i),m.current[b]({[b]:O(V.current,b)}),(x.current.isDirty||x.current.dirtyFields)&&s.shouldDirty&&(D(f.current.dirtyFields,r,Nr(i,O(C.current,r,[]),O(f.current.dirtyFields,r,[]))),F({isDirty:!Z(Object.assign(Object.assign({},ae()),{[r]:i}),C.current)}))}!o&&D(R.current,r,i)},[Oe,pe,Je]),Ue=r=>J.current||w.current.has(r)||w.current.has((r.match(/\w+/)||[])[0]),Ae=r=>{let i=!0;if(!k(M.current))for(const s in M.current)(!r||!M.current[s].size||M.current[s].has(r)||M.current[s].has(we(r)))&&(B.current[s](),i=!1);return i};function pr(r,i,s){Qe(r,i,s||{}),Ue(r)&&F(),Ae(r)}W.current=W.current?W.current:async({type:r,target:i})=>{let s=i.name;const b=a.current[s];let g,d;if(b){const h=r===ie.BLUR,$=Tr(Object.assign({isBlurEvent:h,isReValidateOnChange:qe,isReValidateOnBlur:Ge,isTouched:!!O(f.current.touched,s),isSubmitted:f.current.isSubmitted},I.current));let q=Oe(s,!1),fe=!k(q)||!h&&Ue(s);if(h&&!O(f.current.touched,s)&&x.current.touched&&(D(f.current.touched,s,!0),q=Object.assign(Object.assign({},q),{touched:f.current.touched})),!o&&ue(i)&&D(R.current,s,se(a,s)),$)return!h&&Ae(s),(!k(q)||fe&&k(q))&&F(q);if(ze(),p.current){const{errors:j}=await p.current(ae(),A.current,H),Re=f.current.isValid;if(g=O(j,s),ue(i)&&!g&&p.current){const U=we(s),re=O(j,U,{});re.type&&re.message&&(g=re),U&&(re||O(f.current.errors,U))&&(s=U)}d=k(j),Re!==d&&(fe=!0)}else g=(await Fe(a,H,b,R))[s];!h&&Ae(s),ve(s,g,fe,q,d)}};function Xe(r){if(!o){let i=X(r);for(const s of S.current)me(s)&&!i[s]&&(i=Object.assign(Object.assign({},i),{[s]:[]}));return i}return r}function ae(r){if(z(r))return se(a,r,R);if(Array.isArray(r)){const i={};for(const s of r)D(i,s,se(a,s,R));return i}return Xe(Te(a,X(R.current),o))}const Se=y.useCallback(async(r={})=>{const{errors:i}=await p.current(Object.assign(Object.assign({},ae()),r),A.current,H),s=k(i);f.current.isValid!==s&&F({isValid:s})},[H]),De=y.useCallback((r,i)=>Lr(a,W.current,r,R,o,i),[o]),Ne=y.useCallback(r=>{if(J.current)F();else{for(const i of w.current)if(i.startsWith(r)){F();break}Ae(r)}},[]),Ce=y.useCallback((r,i)=>{r&&(De(r,i),o&&!ce(r.options||[]).length&&(T(N.current,r.ref.name),T(E.current,r.ref.name),T(f.current.errors,r.ref.name),D(f.current.dirtyFields,r.ref.name,!0),F({isDirty:xe()}),x.current.isValid&&p.current&&Se(),Ne(r.ref.name)))},[Se,De]);function Or(r){r&&(Array.isArray(r)?r:[r]).forEach(i=>a.current[i]&&me(i)?delete f.current.errors[i]:T(f.current.errors,i)),F({errors:r?f.current.errors:{}})}function Vr(r,i){const s=(a.current[r]||{}).ref;D(f.current.errors,r,Object.assign(Object.assign({},i),{ref:s})),F({isValid:!1}),i.shouldFocus&&s&&s.focus&&s.focus()}const Ie=y.useCallback((r,i,s)=>{const b=s?M.current[s]:w.current;let g=Te(a,X(R.current),o,!1,r);if(z(r)){const h=we(r)||r;return S.current.has(h)&&(g=Object.assign(Object.assign({},G.current),g)),ir(g,r,b,L(O(C.current,r))?i:O(C.current,r),!0)}const d=L(i)?C.current:i;return Array.isArray(r)?r.reduce((h,$)=>Object.assign(Object.assign({},h),{[$]:ir(g,$,b,d)}),{}):(J.current=L(s),Pe(!k(g)&&g||d))},[]);function Ar(r,i){return Ie(r,i)}function Rr(r){for(const i of Array.isArray(r)?r:[r])Ce(a.current[i],!0)}function Me(r,i={}){const{name:s,type:b,value:g}=r,d=Object.assign({ref:r},i),h=a.current,$=ur(r),q=Br(S.current,s),fe=te=>de&&(!ye(r)||te===r);let j=h[s],Re=!0,U;if(j&&($?Array.isArray(j.options)&&ce(j.options).find(te=>g===te.ref.value&&fe(te.ref)):fe(j.ref))){h[s]=Object.assign(Object.assign({},j),i);return}b?j=$?Object.assign({options:[...ce(j&&j.options||[]),{ref:r}],ref:{type:b,name:s}},i):Object.assign({},d):j=d,h[s]=j;const re=L(O(R.current,s));(!k(C.current)||!re)&&(U=O(re?C.current:R.current,s),Re=L(U),!Re&&!q&&pe(s,U)),k(i)||(D(E.current,s,!0),!Q&&x.current.isValid&&Fe(a,H,j,R).then(te=>{const Cr=f.current.isValid;k(te)?D(N.current,s,!0):T(N.current,s),Cr!==k(te)&&F()})),o&&!(q&&Re)&&!q&&T(f.current.dirtyFields,s),b&&Fr($&&j.options?j.options[j.options.length-1]:j,$||Wr(r),W.current)}function mr(r,i){if(!$r)if(z(r))Me({name:r},i);else if(P(r)&&"name"in r)Me(r,i);else return s=>s&&Me(s,r)}const kr=y.useCallback((r,i)=>async s=>{s&&s.preventDefault&&(s.preventDefault(),s.persist());let b={},g=Xe(Te(a,X(R.current),o,!0));x.current.isSubmitting&&F({isSubmitting:!0});try{if(p.current){const{errors:d,values:h}=await p.current(g,A.current,H);f.current.errors=b=d,g=h}else for(const d of Object.values(a.current))if(d){const{name:h}=d.ref,$=await Fe(a,H,d,R);$[h]?(D(b,h,$[h]),T(N.current,h)):O(E.current,h)&&(T(f.current.errors,h),D(N.current,h,!0))}k(b)&&Object.keys(f.current.errors).every(d=>d in a.current)?(F({errors:{},isSubmitting:!0}),await r(g,s)):(f.current.errors=Object.assign(Object.assign({},f.current.errors),b),i&&await i(f.current.errors,s),u&&wr(a.current,f.current.errors))}finally{f.current.isSubmitting=!1,F({isSubmitted:!0,isSubmitting:!1,isSubmitSuccessful:k(f.current.errors),submitCount:f.current.submitCount+1})}},[u,H]),Er=({errors:r,isDirty:i,isSubmitted:s,touched:b,isValid:g,submitCount:d,dirtyFields:h})=>{g||(N.current={},E.current={}),V.current={},w.current=new Set,J.current=!1,F({submitCount:d?f.current.submitCount:0,isDirty:i?f.current.isDirty:!1,isSubmitted:s?f.current.isSubmitted:!1,isValid:g?f.current.isValid:!1,dirtyFields:h?f.current.dirtyFields:{},touched:b?f.current.touched:{},errors:r?f.current.errors:{},isSubmitting:!1,isSubmitSuccessful:!1})},Sr=(r,i={})=>{if(de){for(const s of Object.values(a.current))if(s){const{ref:b,options:g}=s,d=ur(b)&&Array.isArray(g)?g[0].ref:b;if(ye(d))try{d.closest("form").reset();break}catch{}}}a.current={},C.current=Object.assign({},r||C.current),r&&Ae(""),Object.values(m.current).forEach(s=>hr(s)&&s()),R.current=o?{}:X(r||C.current),Er(i)};y.useEffect(()=>{n&&x.current.isValid&&Se(),he.current=he.current||!de?he.current:Hr(a,Ce)},[Ce,C.current]),y.useEffect(()=>()=>{he.current&&he.current.disconnect(),ge.current=!0,Object.values(a.current).forEach(r=>Ce(r,!0))},[]),!n&&x.current.isValid&&(oe.isValid=Z(N.current,E.current)&&k(f.current.errors));const Ye={trigger:Ve,setValue:y.useCallback(pr,[Qe,Ve]),getValues:y.useCallback(ae,[]),register:y.useCallback(mr,[C.current]),unregister:y.useCallback(Rr,[]),formState:ne?new Proxy(oe,{get:(r,i)=>{if(i in r)return x.current[i]=!0,r[i]}}):oe},Dr=y.useMemo(()=>Object.assign({isFormDirty:xe,updateWatchedValue:Ne,shouldUnregister:o,updateFormState:F,removeFieldEventListener:De,watchInternal:Ie,mode:I.current,reValidateMode:{isReValidateOnBlur:Ge,isReValidateOnChange:qe},validateResolver:n?Se:void 0,fieldsRef:a,resetFieldArrayFunctionRef:m,useWatchFieldsRef:M,useWatchRenderFunctionsRef:B,fieldArrayDefaultValuesRef:V,validFieldsRef:N,fieldsWithValidationRef:E,fieldArrayNamesRef:S,readFormStateRef:x,formStateRef:f,defaultValuesRef:C,shallowFieldsStateRef:R,fieldArrayValuesRef:G},Ye),[C.current,Ne,o,De,Ie]);return Object.assign({watch:Ar,control:Dr,handleSubmit:kr,reset:y.useCallback(Sr,[]),clearErrors:y.useCallback(Or,[]),setError:y.useCallback(Vr,[]),errors:oe.errors},Ye)}const _r=y.createContext(null);_r.displayName="RHFContext";export{Pe as t,qr as u};
